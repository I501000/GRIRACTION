"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.enumTypeForName = exports.complexTypeForName = exports.findEnumType = exports.findComplexType = exports.createEntityClassNames = exports.navigationPropertyBase = exports.joinEntityMetadata = exports.transformEntityBase = void 0;
const util_1 = require("@sap-cloud-sdk/util");
const generator_utils_1 = require("../../generator-utils");
const name_formatting_strategies_1 = require("../../name-formatting-strategies");
const description_util_1 = require("../description-util");
const edmx_to_vdm_util_1 = require("../edmx-to-vdm-util");
const logger = (0, util_1.createLogger)({
    package: 'generator',
    messageContext: 'entity'
});
/**
 * @internal
 */
function transformEntityBase(entityMetadata, classNames, complexTypes, enumTypes, formatter) {
    const entity = {
        entitySetName: entityMetadata.entitySet.Name,
        entityTypeName: entityMetadata.entityType.Name,
        entityTypeNamespace: entityMetadata.entityType.Namespace,
        className: classNames[entityMetadata.entitySet.Name],
        properties: properties(entityMetadata, complexTypes, formatter, enumTypes),
        creatable: entityMetadata.entitySet
            ? (0, generator_utils_1.isCreatable)(entityMetadata.entitySet)
            : true,
        updatable: entityMetadata.entitySet
            ? (0, generator_utils_1.isUpdatable)(entityMetadata.entitySet)
            : true,
        deletable: entityMetadata.entitySet
            ? (0, generator_utils_1.isDeletable)(entityMetadata.entitySet)
            : true
    };
    return {
        ...entity,
        keys: keys(entity.properties, entityMetadata.entityType.Key.PropertyRef),
        description: (0, description_util_1.entityDescription)(entityMetadata, entity.className)
    };
}
exports.transformEntityBase = transformEntityBase;
function keys(props, edmxKeys) {
    return edmxKeys
        .map(key => props.find(prop => prop.originalName === key.Name))
        .filter(e => !!e);
}
function properties(entity, complexTypes, formatter, enumTypes) {
    return entity.entityType.Property.map(p => {
        (0, edmx_to_vdm_util_1.checkCollectionKind)(p);
        const swaggerProp = entity.swaggerDefinition
            ? entity.swaggerDefinition.properties[p.Name]
            : undefined;
        const instancePropertyName = formatter.originalToInstancePropertyName(entity.entitySet.Name, p.Name);
        const isCollection = (0, edmx_to_vdm_util_1.isCollectionType)(p.Type);
        const parsed = isCollection ? (0, edmx_to_vdm_util_1.parseCollectionTypeName)(p.Type) : p.Type;
        const isComplex = (0, edmx_to_vdm_util_1.isComplexType)(parsed, complexTypes);
        const isEnum = (0, edmx_to_vdm_util_1.isEnumType)(parsed, enumTypes);
        const typeMapping = getTypeMappingEntityProperties(p.Type, complexTypes, enumTypes, isComplex, isEnum);
        return {
            originalName: p.Name,
            instancePropertyName,
            staticPropertyName: formatter.originalToStaticPropertyName(entity.entitySet.Name, p.Name),
            propertyNameAsParam: (0, name_formatting_strategies_1.applyPrefixOnJsConflictParam)(instancePropertyName),
            edmType: typeMapping.edmType,
            jsType: typeMapping.jsType,
            fieldType: typeMapping.fieldType,
            description: (0, description_util_1.propertyDescription)(p, swaggerProp),
            nullable: (0, generator_utils_1.isNullableProperty)(p),
            maxLength: p.MaxLength,
            isComplex,
            isEnum,
            isCollection
        };
    });
}
/**
 * @internal
 */
function joinEntityMetadata(entitySets, entityTypes, swagger) {
    return entitySets.map(entitySet => {
        const entityType = entityTypes.find(t => `${t.Namespace}.${t.Name}` === entitySet.EntityType);
        if (!entityType) {
            throw Error(`Could not find entity type '${entitySet.EntityType}' for entity set with name '${entitySet.Name}'.'`);
        }
        const joined = {
            entitySet,
            entityType
        };
        if (swagger) {
            const defKey = Object.keys(swagger.definitions).find(name => `${entityType.Namespace}.${name}` === entitySet.EntityType);
            if (defKey) {
                joined.swaggerDefinition = swagger.definitions[defKey];
            }
        }
        return joined;
    });
}
exports.joinEntityMetadata = joinEntityMetadata;
/**
 * @internal
 */
function navigationPropertyBase(navPropName, entitySetName, formatter) {
    const instancePropertyName = formatter.originalToNavigationPropertyName(entitySetName, navPropName);
    return {
        originalName: navPropName,
        instancePropertyName,
        staticPropertyName: formatter.originalToStaticPropertyName(entitySetName, navPropName),
        propertyNameAsParam: (0, name_formatting_strategies_1.applyPrefixOnJsConflictParam)(instancePropertyName)
    };
}
exports.navigationPropertyBase = navigationPropertyBase;
/**
 * @internal
 */
function createEntityClassNames(entityMetadata, formatter) {
    return entityMetadata.reduce((names, e) => ({
        ...names,
        [e.entitySet.Name]: formatter.originalToEntityClassName(e.entitySet.Name)
    }), {});
}
exports.createEntityClassNames = createEntityClassNames;
function getTypeMappingEntityProperties(typeName, complexTypes, enumTypes, isComplex, isEnum) {
    if ((0, edmx_to_vdm_util_1.isEdmType)(typeName)) {
        const edmFallback = (0, generator_utils_1.getFallbackEdmTypeIfNeeded)(typeName);
        return {
            edmType: edmFallback,
            jsType: (0, generator_utils_1.edmToTsType)(edmFallback),
            fieldType: (0, generator_utils_1.edmToFieldType)(edmFallback)
        };
    }
    if ((0, edmx_to_vdm_util_1.isCollectionType)(typeName)) {
        return (0, edmx_to_vdm_util_1.typesForCollection)(typeName, enumTypes, complexTypes);
    }
    if (isComplex) {
        return {
            edmType: typeName,
            jsType: complexTypeForName(typeName, complexTypes),
            fieldType: complexTypeFieldForName(typeName, complexTypes)
        };
    }
    if (isEnum) {
        return {
            edmType: typeName,
            jsType: enumTypeForName(typeName, enumTypes),
            fieldType: 'EnumField'
        };
    }
    throw new Error(`No types found for ${typeName}`);
}
function complexTypeFieldForName(name, complexTypes) {
    const complexType = (0, exports.findComplexType)(name, complexTypes);
    if (complexType) {
        return (0, edmx_to_vdm_util_1.complexTypeFieldType)(complexType.typeName);
    }
    logger.warn(`No complex type mapping found for ${name}! Using "any" instead. This will most likely result in errors.`);
    return 'any';
}
const getPostfix = (type) => (0, util_1.last)(type.split('.'));
/**
 * @internal
 */
const findComplexType = (name, complexTypes) => complexTypes.find(c => c.originalName === getPostfix(name));
exports.findComplexType = findComplexType;
/**
 * @internal
 */
const findEnumType = (name, enumTypes) => enumTypes.find(e => e.originalName === getPostfix(name));
exports.findEnumType = findEnumType;
/**
 * @internal
 */
function complexTypeForName(name, complexTypes) {
    const complexType = (0, exports.findComplexType)(name, complexTypes);
    if (complexType) {
        return complexType.typeName;
    }
    logger.warn(`No complex type mapping found for ${name}! Using "any" instead. This will most likely result in errors.`);
    return 'any';
}
exports.complexTypeForName = complexTypeForName;
/**
 * @internal
 */
function enumTypeForName(name, enumTypes) {
    const enumType = (0, exports.findEnumType)(name, enumTypes);
    if (enumType) {
        return enumType.typeName;
    }
    logger.warn(`No enum type mapping found for ${name}! Using "any" instead. This will most likely result in errors.`);
    return 'any';
}
exports.enumTypeForName = enumTypeForName;
//# sourceMappingURL=entity.js.map