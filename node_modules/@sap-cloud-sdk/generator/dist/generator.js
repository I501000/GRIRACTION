"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSourcesForService = exports.generateProject = exports.transpileDirectories = exports.getInstallODataErrorMessage = exports.generate = void 0;
const path_1 = require("path");
const util_1 = require("@sap-cloud-sdk/util");
const fs_extra_1 = require("fs-extra");
const ts_morph_1 = require("ts-morph");
const typescript_1 = require("typescript");
const glob_1 = require("glob");
const internal_1 = require("@sap-cloud-sdk/generator-common/internal");
const file_1 = require("./batch/file");
const file_2 = require("./complex-type/file");
const file_3 = require("./entity/file");
const file_generator_1 = require("./file-generator");
const generator_options_1 = require("./generator-options");
const generator_utils_1 = require("./generator-utils");
const service_generator_1 = require("./service-generator");
const file_4 = require("./request-builder/file");
const service_mapping_1 = require("./service-mapping");
const csn_1 = require("./service/csn");
const index_file_1 = require("./service/index-file");
const npmrc_1 = require("./service/npmrc");
const package_json_1 = require("./service/package-json");
const readme_1 = require("./service/readme");
const ts_config_1 = require("./service/ts-config");
const file_5 = require("./action-function-import/file");
const file_6 = require("./enum-type/file");
const sdk_metadata_1 = require("./sdk-metadata");
const create_file_1 = require("./generator-common/create-file");
const generator_without_ts_morph_1 = require("./generator-without-ts-morph");
const file_7 = require("./generator-without-ts-morph/service/file");
const logger = (0, util_1.createLogger)({
    package: 'generator',
    messageContext: 'generator'
});
/**
 * Main entry point for the OData client generation.
 * Generates models and API files.
 * @param options - Options to configure generation.
 */
async function generate(options) {
    var _a;
    const projectAndServices = await generateProject(options);
    if (!projectAndServices) {
        throw Error('The project is undefined.');
    }
    const project = projectAndServices.project;
    const services = projectAndServices.services;
    await project.save();
    await generateFilesWithoutTsMorph(services, options);
    if (options.generateJs) {
        const directories = project
            .getDirectories()
            .filter(dir => !!dir.getSourceFile('tsconfig.json'));
        const chunks = (0, util_1.splitInChunks)(directories, options.processesJsGeneration || generator_options_1.defaultValueProcessesJsGeneration);
        try {
            await chunks.reduce((all, chunk) => all.then(() => transpileDirectories(chunk)), Promise.resolve());
        }
        catch (err) {
            if ((_a = err.message) === null || _a === void 0 ? void 0 : _a.includes('error TS2307')) {
                throw new util_1.ErrorWithCause(getInstallODataErrorMessage(projectAndServices), err);
            }
            throw err;
        }
    }
}
exports.generate = generate;
/**
 * @internal
 * @param projectAndServices - Generated project with services.
 * @returns An error message with a recommendation to install specific SDK packages.
 */
function getInstallODataErrorMessage(projectAndServices) {
    const hasV2 = projectAndServices.services.some(service => service.oDataVersion === 'v2');
    const hasV4 = projectAndServices.services.some(service => service.oDataVersion === 'v4');
    if (hasV2 && hasV4) {
        return 'Did you forget to install "@sap-cloud-sdk/odata-v2" and "@sap-cloud-sdk/odata-v4"?';
    }
    return `Did you forget to install "@sap-cloud-sdk/odata-v${hasV2 ? '2' : '4'}"?`;
}
exports.getInstallODataErrorMessage = getInstallODataErrorMessage;
/**
 * @internal
 */
async function transpileDirectories(directories) {
    return Promise.all(directories.map(async (directory) => {
        const compilerOptions = await (0, internal_1.readCompilerOptions)(directory.getPath());
        return (0, internal_1.transpileDirectory)(directory.getPath(), compilerOptions);
    }));
}
exports.transpileDirectories = transpileDirectories;
/**
 * @internal
 */
async function generateProject(options) {
    options = sanitizeOptions(options);
    const services = parseServices(options);
    if (!services.length) {
        logger.warn('No services parsed.');
        return;
    }
    if (options.clearOutputDir) {
        (0, fs_extra_1.emptyDirSync)(options.outputDir.toString());
    }
    const project = new ts_morph_1.Project(projectOptions());
    const promises = services.map(service => generateSourcesForService(service, project, options));
    await Promise.all(promises);
    if (!options.serviceMapping) {
        throw Error('The service mapping is undefined.');
    }
    project.createSourceFile((0, path_1.resolve)(options.serviceMapping.toString()), (0, service_mapping_1.serviceMappingFile)(services), { overwrite: true });
    return { project, services };
}
exports.generateProject = generateProject;
async function generateFilesWithoutTsMorph(services, options) {
    const promises = services.flatMap(service => [
        generateEntityApis(service, options),
        generateServiceFile(service, options),
        generateAdditionalFiles(service, options)
    ]);
    await Promise.all(promises);
}
async function generateAdditionalFiles(service, options) {
    if (options.additionalFiles) {
        const additionalFilesDir = (0, path_1.resolve)(options.inputDir.toString(), options.additionalFiles)
            .split(path_1.sep)
            .join(path_1.posix.sep);
        const serviceDir = resolvePath(service.directoryName, options);
        const files = new glob_1.GlobSync(additionalFilesDir).found;
        await (0, internal_1.copyFiles)(files, serviceDir, options.forceOverwrite);
    }
}
async function generateServiceFile(service, options) {
    const serviceDir = resolvePath(service.directoryName, options);
    await (0, create_file_1.createFile)(serviceDir, 'service.ts', (0, file_7.serviceFile)(service), options.forceOverwrite);
}
async function generateEntityApis(service, options) {
    const serviceDir = resolvePath(service.directoryName, options);
    await Promise.all(service.entities.map(entity => (0, create_file_1.createFile)(serviceDir, `${entity.className}Api.ts`, (0, generator_without_ts_morph_1.entityApiFile)(entity, service), options.forceOverwrite)));
}
/**
 * @internal
 */
async function generateSourcesForService(service, project, options) {
    const serviceDir = project.createDirectory(resolvePath(service.directoryName, options));
    logger.info(`[${service.originalFileName}] Generating entities ...`);
    if (options.generatePackageJson) {
        (0, file_generator_1.otherFile)(serviceDir, 'package.json', await (0, package_json_1.packageJson)({
            npmPackageName: service.npmPackageName,
            version: await (0, internal_1.getVersionForClient)(options.versionInPackageJson),
            sdkVersion: await (0, internal_1.getSdkVersion)(),
            description: (0, sdk_metadata_1.getServiceDescription)(service, options),
            sdkAfterVersionScript: options.sdkAfterVersionScript,
            oDataVersion: service.oDataVersion,
            license: options.licenseInPackageJson
        }), options.forceOverwrite);
    }
    (0, file_generator_1.otherFile)(serviceDir, 'tsconfig.json', (0, ts_config_1.tsConfig)(), options.forceOverwrite);
    if ((0, generator_utils_1.hasEntities)(service)) {
        logger.info(`[${service.originalFileName}] Generating batch request builder ...`);
        (0, file_generator_1.sourceFile)(serviceDir, 'BatchRequest', (0, file_1.batchSourceFile)(service), options.forceOverwrite);
    }
    service.entities.forEach(entity => {
        logger.info(`Generating entity: ${entity.className}...`);
        (0, file_generator_1.sourceFile)(serviceDir, entity.className, (0, file_3.entitySourceFile)(entity, service), options.forceOverwrite);
        (0, file_generator_1.sourceFile)(serviceDir, `${entity.className}RequestBuilder`, (0, file_4.requestBuilderSourceFile)(entity, service.oDataVersion), options.forceOverwrite);
    });
    service.enumTypes.forEach(enumType => {
        logger.info(`[${service.originalFileName}] Generating enum type ${enumType.originalName} ...`);
        (0, file_generator_1.sourceFile)(serviceDir, enumType.typeName, (0, file_6.enumTypeSourceFile)(enumType), options.forceOverwrite);
    });
    service.complexTypes.forEach(complexType => {
        logger.info(`[${service.originalFileName}] Generating complex type ${complexType.originalName} ...`);
        (0, file_generator_1.sourceFile)(serviceDir, complexType.typeName, (0, file_2.complexTypeSourceFile)(complexType, service.oDataVersion), options.forceOverwrite);
    });
    if (service.functionImports && service.functionImports.length) {
        logger.info(`[${service.originalFileName}] Generating function imports ...`);
        (0, file_generator_1.sourceFile)(serviceDir, 'function-imports', (0, file_5.functionImportSourceFile)(service), options.forceOverwrite);
    }
    if (service.actionImports && service.actionImports.length) {
        logger.info(`[${service.originalFileName}] Generating action imports ...`);
        (0, file_generator_1.sourceFile)(serviceDir, 'action-imports', (0, file_5.actionImportSourceFile)(service), options.forceOverwrite);
    }
    (0, file_generator_1.sourceFile)(serviceDir, 'index', (0, index_file_1.indexFile)(service), options.forceOverwrite);
    if (options.writeReadme) {
        logger.info(`[${service.originalFileName}] Generating readme ...`);
        (0, file_generator_1.otherFile)(serviceDir, 'README.md', (0, readme_1.readme)(service, options.s4hanaCloud), options.forceOverwrite);
    }
    if (options.generateNpmrc) {
        logger.info(`[${service.originalFileName}] Generating .npmrc for ...`);
        (0, file_generator_1.otherFile)(serviceDir, '.npmrc', (0, npmrc_1.npmrc)(), options.forceOverwrite);
    }
    if (options.generateCSN) {
        try {
            logger.info(`[${service.originalFileName}] Generating ${service.directoryName}-csn.json ...`);
            (0, file_generator_1.otherFile)(serviceDir, `${service.directoryName}-csn.json`, await (0, csn_1.csn)(service), options.forceOverwrite);
        }
        catch (e) {
            logger.error(`CSN creation for service ${service.originalFileName} failed. Original error: ${e.message}`);
        }
    }
    if (options.generateSdkMetadata) {
        const { clientFileName, headerFileName } = (0, internal_1.getSdkMetadataFileNames)(service.originalFileName);
        logger.info(`Generating sdk header metadata ${headerFileName}...`);
        const metadataDir = project.createDirectory((0, path_1.resolve)((0, path_1.dirname)(service.edmxPath.toString()), 'sdk-metadata'));
        (0, file_generator_1.otherFile)(metadataDir, headerFileName, JSON.stringify(await (0, internal_1.sdkMetadataHeader)('odata', service.originalFileName, options.versionInPackageJson), null, 2), options.forceOverwrite);
        logger.info(`Generating sdk client metadata ${clientFileName}...`);
        (0, file_generator_1.otherFile)(metadataDir, clientFileName, JSON.stringify(await (0, sdk_metadata_1.sdkMetadata)(service, options), null, 2), options.forceOverwrite);
    }
}
exports.generateSourcesForService = generateSourcesForService;
function projectOptions() {
    return {
        skipAddingFilesFromTsConfig: true,
        manipulationSettings: {
            indentationText: ts_morph_1.IndentationText.TwoSpaces,
            insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces: true,
            quoteKind: ts_morph_1.QuoteKind.Single
        },
        compilerOptions: {
            target: ts_morph_1.ScriptTarget.ES2019,
            module: typescript_1.ModuleKind.CommonJS,
            declaration: true,
            declarationMap: true,
            sourceMap: true,
            diagnostics: true,
            moduleResolution: ts_morph_1.ModuleResolutionKind.NodeJs,
            esModuleInterop: true,
            inlineSources: false,
            noImplicitAny: true
        }
    };
}
function parseServices(options) {
    const services = (0, service_generator_1.parseAllServices)(options);
    if (!services.length) {
        logger.warn('No service definition files found.');
        return [];
    }
    return services;
}
function sanitizeOptions(options) {
    options.serviceMapping =
        options.serviceMapping ||
            (0, path_1.resolve)(options.inputDir.toString(), 'service-mapping.json');
    return options;
}
function resolvePath(path, options) {
    return (0, path_1.resolve)(options.outputDir.toString(), path.toString());
}
//# sourceMappingURL=generator.js.map