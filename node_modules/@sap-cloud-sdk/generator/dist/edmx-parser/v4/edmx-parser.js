"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseActions = exports.parseFunctions = exports.parseActionImport = exports.parseFunctionImportsV4 = exports.parseEntitySetsV4 = exports.parseEntityType = exports.parseEnumTypes = exports.parseComplexTypesV4 = exports.joinTypesWithBaseTypes = exports.joinComplexTypes = void 0;
const edmx_parser_1 = require("../common/edmx-parser");
const generator_utils_1 = require("../../generator-utils");
const v4_1 = require("../../edmx-to-vdm/v4");
const edmx_to_vdm_1 = require("../../edmx-to-vdm");
/**
 * @internal
 */
function joinComplexTypes(complexType, baseType) {
    return {
        ...complexType,
        Property: [...complexType.Property, ...baseType.Property]
    };
}
exports.joinComplexTypes = joinComplexTypes;
/**
 * @internal
 */
function joinTypesWithBaseTypes(types, joinTypes) {
    return types.map(type => joinTypeWithBaseType(type, types, joinTypes));
}
exports.joinTypesWithBaseTypes = joinTypesWithBaseTypes;
/**
 * Recursively adds the base type data to the current type.
 * @param type - An EDMX type that can have a base type (e.g. EntityType or ComplexType).
 * @param types - All parsed EDMX types.
 * @param joinTypes - Function to ultimately join types.
 * @returns The enriched type (type + base type).
 */
function joinTypeWithBaseType(type, types, joinTypes) {
    if (type.BaseType) {
        const baseType = types.find(e => e.Name === (0, edmx_to_vdm_1.stripNamespace)(type.BaseType));
        if (!baseType) {
            throw new Error(`Type ${type.BaseType} not found, but defined as BaseType of Type ${type.Name}.`);
        }
        return joinTypes(type, joinTypeWithBaseType(baseType, types, joinTypes));
    }
    return type;
}
/**
 * @internal
 */
function parseComplexTypesV4(root) {
    return joinTypesWithBaseTypes((0, edmx_parser_1.parseComplexTypesBase)(root), joinComplexTypes);
}
exports.parseComplexTypesV4 = parseComplexTypesV4;
/**
 * @internal
 */
function parseEnumTypes(root) {
    return (0, edmx_parser_1.getMergedPropertyWithNamespace)(root, 'EnumType').map(edmxEnumType => ({
        Name: edmxEnumType.Name,
        UnderlyingType: edmxEnumType.UnderlyingType,
        Member: (0, generator_utils_1.forceArray)(edmxEnumType.Member),
        Namespace: edmxEnumType.Namespace
    }));
}
exports.parseEnumTypes = parseEnumTypes;
/**
 * @internal
 */
function parseEntityType(root) {
    const entityTypes = (0, edmx_parser_1.parseEntityTypesBase)(root);
    return joinTypesWithBaseTypes(entityTypes, v4_1.joinEntityTypes);
}
exports.parseEntityType = parseEntityType;
/**
 * @internal
 */
function parseEntitySetsV4(root) {
    return (0, edmx_parser_1.parseEntitySetsBase)(root).map(entitySet => ({
        ...entitySet,
        NavigationPropertyBinding: parseNavigationPropertyBinding(entitySet)
    }));
}
exports.parseEntitySetsV4 = parseEntitySetsV4;
function parseNavigationPropertyBinding(entitySet) {
    return (0, generator_utils_1.forceArray)(entitySet.NavigationPropertyBinding);
}
/**
 * @internal
 */
function parseFunctionImportsV4(root) {
    return (0, edmx_parser_1.getPropertyFromEntityContainer)(root, 'FunctionImport');
}
exports.parseFunctionImportsV4 = parseFunctionImportsV4;
/**
 * @internal
 */
function parseActionImport(root) {
    return (0, edmx_parser_1.getPropertyFromEntityContainer)(root, 'ActionImport');
}
exports.parseActionImport = parseActionImport;
function parseActionsFunctions(root, actionFunctionKey) {
    return (0, edmx_parser_1.getMergedPropertyWithNamespace)(root, actionFunctionKey).map(actionOrFunction => ({
        ...actionOrFunction,
        Parameter: (0, generator_utils_1.forceArray)(actionOrFunction.Parameter),
        IsBound: false
    }));
}
/**
 * @internal
 */
function parseFunctions(root) {
    return parseActionsFunctions(root, 'Function');
}
exports.parseFunctions = parseFunctions;
/**
 * @internal
 */
function parseActions(root) {
    return parseActionsFunctions(root, 'Action');
}
exports.parseActions = parseActions;
//# sourceMappingURL=edmx-parser.js.map