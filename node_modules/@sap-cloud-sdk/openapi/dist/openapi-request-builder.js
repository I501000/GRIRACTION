"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpenApiRequestBuilder = void 0;
const util_1 = require("@sap-cloud-sdk/util");
const connectivity_1 = require("@sap-cloud-sdk/connectivity");
const internal_1 = require("@sap-cloud-sdk/connectivity/internal");
const http_client_1 = require("@sap-cloud-sdk/http-client");
const internal_2 = require("@sap-cloud-sdk/http-client/internal");
/**
 * Request builder for OpenAPI requests.
 * @typeParam ResponseT - Type of the response for the request.
 */
class OpenApiRequestBuilder {
    /**
     * Create an instance of `OpenApiRequestBuilder`.
     * @param method - HTTP method of the request to be built.
     * @param pathPattern - Path for the request containing path parameter references as in the OpenAPI specification.
     * @param parameters - Query parameters and or body to pass to the request.
     */
    constructor(method, pathPattern, parameters) {
        this.method = method;
        this.pathPattern = pathPattern;
        this.parameters = parameters;
        this.customHeaders = {};
        this.customRequestConfiguration = {};
        this._fetchCsrfToken = true;
        this._timeout = undefined;
    }
    static isPlaceholder(pathPart) {
        return /^\{.+\}$/.test(pathPart);
    }
    /**
     * Add custom headers to the request. If a header field with the given name already exists it is overwritten.
     * @param headers - Key-value pairs denoting additional custom headers.
     * @returns The request builder itself, to facilitate method chaining.
     */
    addCustomHeaders(headers) {
        Object.entries(headers).forEach(([key, value]) => {
            this.customHeaders[key.toLowerCase()] = value;
        });
        return this;
    }
    /**
     * Add custom request configuration to the request. Typically, this is used when specifying response type for downloading files.
     * If the custom request configuration contains keys in this list [[defaultDisallowedKeys]], they will be removed.
     * @param requestConfiguration - Key-value pairs denoting additional custom request configuration options to be set in the request.
     * @returns The request builder itself, to facilitate method chaining.
     */
    addCustomRequestConfiguration(requestConfiguration) {
        Object.entries(requestConfiguration).forEach(([key, value]) => {
            this.customRequestConfiguration[key] = value;
        });
        return this;
    }
    /**
     * Skip fetching csrf token for this request, which is typically useful when the csrf token is not required.
     * @returns The request builder itself, to facilitate method chaining.
     */
    skipCsrfTokenFetching() {
        this._fetchCsrfToken = false;
        return this;
    }
    /**
     * Set timeout for requests towards the target system given in the destination.
     * @param timeout - Value is in milliseconds and default value is 10000 (10 seconds).
     * @returns The request builder itself, to facilitate method chaining.
     */
    timeout(timeout) {
        this._timeout = timeout;
        return this;
    }
    /**
     * Execute request and get a raw HttpResponse, including all information about the HTTP response.
     * This especially comes in handy, when you need to access the headers or status code of the response.
     * @param destination - Destination or DestinationFetchOptions to execute the request against.
     * @returns A promise resolving to an HttpResponse.
     */
    async executeRaw(destination) {
        const fetchCsrfToken = this._fetchCsrfToken &&
            ['post', 'put', 'patch', 'delete'].includes(this.method.toLowerCase());
        const resolvedDestination = await (0, connectivity_1.useOrFetchDestination)(destination);
        if ((0, util_1.isNullish)(destination)) {
            throw Error((0, internal_1.noDestinationErrorMessage)(destination));
        }
        return (0, http_client_1.executeHttpRequest)(resolvedDestination, await this.requestConfig(), { fetchCsrfToken });
    }
    /**
     * Execute request and get the response data. Use this to conveniently access the data of a service without technical information about the response.
     * @param destination - Destination or DestinationFetchOptions to execute the request against.
     * @returns A promise resolving to the requested return type.
     */
    async execute(destination) {
        const response = await this.executeRaw(destination);
        if (isAxiosResponse(response)) {
            return response.data;
        }
        throw new Error('Could not access response data. Response was not an axios response.');
    }
    /**
     * Get http request config.
     * @returns Promise of http request config with origin.
     */
    async requestConfig() {
        var _a;
        const defaultConfig = {
            method: this.method,
            url: this.getPath(),
            headers: this.getHeaders(),
            params: this.getParameters(),
            timeout: this._timeout,
            parameterEncoder: internal_2.encodeTypedClientRequest,
            data: (_a = this.parameters) === null || _a === void 0 ? void 0 : _a.body
        };
        return {
            ...defaultConfig,
            ...(0, internal_2.filterCustomRequestConfig)(this.customRequestConfiguration)
        };
    }
    getHeaders() {
        if (Object.keys(this.customHeaders).length > 0) {
            return { custom: this.customHeaders, requestConfig: {} };
        }
        return { requestConfig: {} };
    }
    getParameters() {
        var _a;
        return { requestConfig: ((_a = this.parameters) === null || _a === void 0 ? void 0 : _a.queryParameters) || {} };
    }
    getPath() {
        var _a;
        const pathParameters = ((_a = this.parameters) === null || _a === void 0 ? void 0 : _a.pathParameters) || {};
        // Get the innermost curly bracket pairs with non-empty and legal content as placeholders.
        const placeholders = this.pathPattern.match(/{[^/?#{}]+}/g) || [];
        return placeholders.reduce((path, placeholder) => {
            const strippedPlaceholder = placeholder.slice(1, -1);
            const parameterValue = pathParameters[strippedPlaceholder];
            return path.replace(placeholder, encodeURIComponent(parameterValue));
        }, this.pathPattern);
    }
}
exports.OpenApiRequestBuilder = OpenApiRequestBuilder;
function isAxiosResponse(val) {
    return 'data' in val;
}
//# sourceMappingURL=openapi-request-builder.js.map