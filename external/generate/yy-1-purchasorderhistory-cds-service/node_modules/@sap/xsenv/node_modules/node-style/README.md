node-style
==========

Node.js code conventions for SAP HANA XS Advanced

This guide is a recommendation for writing aesthetically pleasant and consistent Node.js code for SAP HANA XS Advanced.
It consists of ```.eslintrc``` which enforce the rules marked as recommended on the following link:

http://eslint.org/docs/rules/

## Usage
Add this package to your devDependencies
```sh
npm install --save-dev node-style
```
In the root directory of your project (next to your _package.json_) create the file _.eslintrc.yml_ with the following content:
```yml
extends: ./node_modules/node-style/.eslintrc
root: true
rules:
  # put any additional rules here
```
Add the following command in your _package.json_:
```json
  "scripts": {
    "lint": "eslint -f stylish --ignore-path .gitignore .",
  }
```

If you use _mocha_ for your tests and keep them under _test_ directory, then create the file _test/.eslintrc.yml_ with the following content:
```yml
env:
  mocha: true
```

To check your code run
```sh
npm run lint
```
This check is also executed automatically by _xmake_.

To fix automatically all fixable issues, run:
```sh
npm run lint -- --fix
```

### Visual Studio Code
If you use Visual Studio Code, eslint is enabled by default so any issues will be highlighted in your code.
If this is not the case, enable the following configuration:
```json
"eslint.enable": true
```
To fix automatically all fixable issues on save, enable this configuration:
```json
"eslint.autoFixOnSave": true
```

## Argument validation

Use `assert` to validate function arguments.
```js
var assert = require('assert');

function connect(host, port) {
  assert(typeof host === 'string', 'host should be a string');
  assert(port > 0 && Math.floor(port) === port, 'port should be a positive integer');
```
Using `assert` is equivalent to `if - throw` but is more concise, so it improves readability and encourages developers to do proper validation.

### When to validate arguments

At least validate arguments at the entry points (API) of your module. The idea is that while you are in control what happens inside your modules, you have no control what input you will get from outside.

Validate external input as early as possible. At least make sure to validate it in the same call stack where you get the external input. This way, in case of error, the stack trace will show the external source of the bad input.

**Do not** store external input and validate it later on at point of use. Then it will be hard the find the source of a bad input.

**Do not** fallback to some default in case of invalid input. Better report the error right away.

## Additional rules

On top of the default recommended rules, we have set additional ones which make the code even more consistent.

* Indentation is made by 2 spaces.
* Use single quotes for strings. Double quotes are allowed, if the string contains single quotes.
* Disallow mixed 'LF' and 'CRLF' as linebreaks. Only 'LF' linebreaks are accepted.
* Require semicolons at the end of each line statement.
* [Put curly braces around blocks.](#curly)
* [Prohibit the use of == and !=.](#eqeqeq)
* [Suppresses warnings about == null.](#eqnull)
* [Prohibit overwriting prototypes of native objects.](#freeze)
* [Maximum depth that blocks can be nested is 4.](#maxdepth)
* [Prohibit the use of constructor functions for side-effects.](#nonew)
* Require all files to have a global 'use strict' statement.
* Forbid trailing whitespaces.
* Forbid spaces inside parentheses.
* Spaces before and after arithmetic operations, including binary operations.
* Space after keywords [if, else, for, while ...].
* Space after comment line.
* CamelCase or UpperCaseIdentifiers.

## curly
This option requires you to always put curly braces around blocks in loops and conditionals. JavaScript allows you to omit curly braces when the block consists of only one statement, for example:
```js
while (day)
  shuffle();
```
However, in some circumstances, it can lead to bugs (you'd think that sleep() is a part of the loop while in reality it is not):
```js
while (day)
  shuffle();
  sleep();
```
## eqeqeq
This options prohibits the use of ```==``` and ```!=``` in favor of ```===``` and ```!==```. The former try to coerce values before comparing them which can lead to some unexpected results. The latter don't do any coercion so they are generally safer. If you would like to learn more about type coercion in JavaScript, we recommend Truth, Equality and JavaScript by Angus Croll.
## eqnull
This option suppresses warnings about ```== null``` comparisons. Such comparisons are often useful when you want to check if a variable is null or undefined.
## freeze
This options prohibits overwriting prototypes of native objects such as Array, Date and so on.
```js
Array.prototype.count = function (value) { return value + 42; };
// -> Error: Extending prototype of native object: 'Array'.
```

## maxdepth
This option prohibits the use of more than 4 nesting blocks:
```js

function main(meaning) {
  var day = true;

  if (meaning === 42) {
    while (day) {
      shuffle();

      if (tired) {
        if(reallyTired) {
          if(alsoBored) {
            sleep(); // -> Error: Blocks are nested too deeply (5).
          }
        }
      }
    }
  }
}
```
## nonew
This option prohibits the use of constructor functions for side-effects. Some people like to call constructor functions without assigning its result to any variable:
```js
new MyConstructor(); // -> Error: Do not use 'new' for side effects
```
There is no advantage in this approach over simply calling MyConstructor since the object that the operator new creates isn't used anywhere so you should generally avoid constructors like this one.

## Known limitations:
* Disable declaring more than one variable with one var statement. It is so important for you, see https://github.com/greggman/eslint-plugin-one-variable-per-var.
* Capitalized constructors can't be disabled.
